(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{349:function(t,a,r){"use strict";r.r(a);var e=r(2),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[t._v("#")]),t._v(" JS")]),t._v(" "),r("blockquote",[r("p",[t._v("问题收集自"),r("a",{attrs:{href:"https://juejin.im/post/5bb470295188255c5e66f88f",target:"_blank",rel:"noopener noreferrer"}},[t._v("段亦心"),r("OutboundLink")],1),t._v("、")])]),t._v(" "),r("h2",{attrs:{id:"面向对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),r("h2",{attrs:{id:"原型链"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),r("h2",{attrs:{id:"闭包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),r("h3",{attrs:{id:"闭包是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#闭包是什么？"}},[t._v("#")]),t._v(" 闭包是什么？")]),t._v(" "),r("p",[t._v("因为作用域链，外部不能访问内部的变量和方法，这时我们就需要通过闭包，返回内部的方法和变量给外部，从而就形成了一个闭包。")]),t._v(" "),r("h3",{attrs:{id:"闭包什么时候会消除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#闭包什么时候会消除"}},[t._v("#")]),t._v(" 闭包什么时候会消除?")]),t._v(" "),r("p",[t._v("JavaScript是一门具有自动垃圾回收机制的编程语言，主要有两种方式：")]),t._v(" "),r("ul",[r("li",[t._v("标记清除（最常用）")])]),t._v(" "),r("p",[t._v("垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。")]),t._v(" "),r("ul",[r("li",[t._v("引用计数")])]),t._v(" "),r("p",[t._v("引用计数（reference counting）的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。\n导致问题：会导致循环引用的变量和函数无法回收。\n解决：将用完的函数或者变量置为null。")]),t._v(" "),r("h2",{attrs:{id:"​var-let和const"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#​var-let和const"}},[t._v("#")]),t._v(" ​var,let和const")]),t._v(" "),r("p",[t._v("​ - var。\n* 全局变量\n* 无变量声明提升，声明前使用会报错 not defined\n​ - let它的出现，我认为主要是解决了块级作用域的需求。\n* 只在块级作用域能使用\n* 无变量声明提升，声明前使用会报错 not defined")])])}),[],!1,null,null,null);a.default=s.exports}}]);